<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ocean Physics Simulator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600&family=Outfit:wght@200;300;400;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    overflow: hidden;
    font-family: 'Outfit', sans-serif;
    color: #e0e8f0;
  }

  canvas { display: block; }

  #ui-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 10;
  }

  #panel {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 340px;
    background: rgba(5, 12, 24, 0.88);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(100, 180, 255, 0.12);
    border-radius: 16px;
    padding: 24px;
    pointer-events: auto;
    z-index: 20;
    box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
    max-height: calc(100vh - 40px);
    overflow-y: auto;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,180,255,0.2) transparent;
  }

  #panel::-webkit-scrollbar { width: 4px; }
  #panel::-webkit-scrollbar-track { background: transparent; }
  #panel::-webkit-scrollbar-thumb { background: rgba(100,180,255,0.2); border-radius: 2px; }

  #panel h1 {
    font-family: 'Outfit', sans-serif;
    font-weight: 200;
    font-size: 22px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: #7ab8ff;
    margin-bottom: 4px;
  }

  #panel .subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: rgba(122,184,255,0.5);
    letter-spacing: 3px;
    text-transform: uppercase;
    margin-bottom: 20px;
  }

  .section {
    margin-bottom: 18px;
    padding-bottom: 16px;
    border-bottom: 1px solid rgba(100,180,255,0.08);
  }

  .section:last-child { border-bottom: none; margin-bottom: 0; }

  .section-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(122,184,255,0.7);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .section-title::before {
    content: '';
    width: 8px;
    height: 2px;
    background: #7ab8ff;
    border-radius: 1px;
  }

  .control-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }

  .control-row label {
    font-size: 12px;
    font-weight: 300;
    color: rgba(200,220,240,0.8);
  }

  .control-row .value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: #7ab8ff;
    min-width: 50px;
    text-align: right;
  }

  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 3px;
    background: rgba(100,180,255,0.15);
    border-radius: 2px;
    outline: none;
    margin-top: 6px;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #7ab8ff;
    cursor: pointer;
    box-shadow: 0 0 8px rgba(122,184,255,0.4);
    transition: transform 0.15s;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  #stats {
    position: fixed;
    bottom: 20px;
    left: 20px;
    pointer-events: auto;
    z-index: 20;
  }

  .stat-grid {
    display: grid;
    grid-template-columns: repeat(4, auto);
    gap: 16px;
    background: rgba(5, 12, 24, 0.85);
    backdrop-filter: blur(16px);
    border: 1px solid rgba(100, 180, 255, 0.1);
    border-radius: 12px;
    padding: 14px 20px;
  }

  .stat-item {
    text-align: center;
  }

  .stat-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px;
    letter-spacing: 2px;
    text-transform: uppercase;
    color: rgba(122,184,255,0.5);
    margin-bottom: 4px;
  }

  .stat-value {
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    font-weight: 500;
    color: #7ab8ff;
  }

  #compass {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 80px;
    height: 80px;
    pointer-events: none;
    z-index: 20;
  }

  .toggle-btn {
    background: rgba(122,184,255,0.1);
    border: 1px solid rgba(122,184,255,0.2);
    color: #7ab8ff;
    padding: 6px 12px;
    border-radius: 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    cursor: pointer;
    letter-spacing: 1px;
    text-transform: uppercase;
    transition: all 0.2s;
    pointer-events: auto;
  }

  .toggle-btn:hover {
    background: rgba(122,184,255,0.2);
    border-color: rgba(122,184,255,0.4);
  }

  .toggle-btn.active {
    background: rgba(122,184,255,0.25);
    border-color: #7ab8ff;
  }

  .btn-row {
    display: flex;
    gap: 8px;
    margin-top: 8px;
  }

  #loading {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: #050c18;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    transition: opacity 0.8s;
  }

  #loading.fade-out { opacity: 0; pointer-events: none; }

  .loading-wave {
    width: 200px;
    height: 4px;
    background: rgba(122,184,255,0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 16px;
  }

  .loading-wave::after {
    content: '';
    display: block;
    width: 60%;
    height: 100%;
    background: linear-gradient(90deg, transparent, #7ab8ff, transparent);
    border-radius: 2px;
    animation: loadWave 1.2s ease-in-out infinite;
  }

  @keyframes loadWave {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(220%); }
  }

  .loading-text {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    letter-spacing: 4px;
    text-transform: uppercase;
    color: rgba(122,184,255,0.6);
  }
</style>
</head>
<body>

<div id="loading">
  <div class="loading-wave"></div>
  <div class="loading-text">Initializing Ocean Physics</div>
</div>

<div id="panel">
  <h1>Ocean Sim</h1>
  <div class="subtitle">Tessendorf FFT · Physics Engine</div>

  <div class="section">
    <div class="section-title">Wind Dynamics</div>
    <div class="control-row">
      <label>Wind Speed</label>
      <span class="value" id="windSpeedVal">12.0 m/s</span>
    </div>
    <input type="range" id="windSpeed" min="0.5" max="40" step="0.5" value="12">
    <div class="control-row" style="margin-top:10px">
      <label>Wind Direction</label>
      <span class="value" id="windDirVal">45°</span>
    </div>
    <input type="range" id="windDir" min="0" max="360" step="1" value="45">
    <div class="control-row" style="margin-top:10px">
      <label>Fetch (km)</label>
      <span class="value" id="fetchVal">800</span>
    </div>
    <input type="range" id="fetchDist" min="10" max="1500" step="10" value="800">
  </div>

  <div class="section">
    <div class="section-title">Wave Physics</div>
    <div class="control-row">
      <label>Wave Height Scale</label>
      <span class="value" id="waveHeightVal">1.0x</span>
    </div>
    <input type="range" id="waveHeight" min="0.1" max="4.0" step="0.1" value="1.0">
    <div class="control-row" style="margin-top:10px">
      <label>Choppiness</label>
      <span class="value" id="chopVal">1.2</span>
    </div>
    <input type="range" id="choppiness" min="0" max="3.0" step="0.1" value="1.2">
    <div class="control-row" style="margin-top:10px">
      <label>Wave Period</label>
      <span class="value" id="periodVal">8.0 s</span>
    </div>
    <input type="range" id="wavePeriod" min="2" max="20" step="0.5" value="8">
  </div>

  <div class="section">
    <div class="section-title">Planet Physics</div>
    <div class="control-row">
      <label>Gravity</label>
      <span class="value" id="gravityVal">9.81 m/s²</span>
    </div>
    <input type="range" id="gravity" min="1" max="25" step="0.1" value="9.81">
    <div class="control-row" style="margin-top:10px">
      <label>Latitude</label>
      <span class="value" id="latitudeVal">45° N</span>
    </div>
    <input type="range" id="latitude" min="-90" max="90" step="1" value="45">
    <div class="control-row" style="margin-top:10px">
      <label>Planet Rotation (Ω)</label>
      <span class="value" id="omegaVal">7.29e-5</span>
    </div>
    <input type="range" id="omega" min="0" max="20" step="0.1" value="7.29">
  </div>

  <div class="section">
    <div class="section-title">Rendering</div>
    <div class="control-row">
      <label>Sun Elevation</label>
      <span class="value" id="sunElVal">35°</span>
    </div>
    <input type="range" id="sunElevation" min="2" max="90" step="1" value="35">
    <div class="control-row" style="margin-top:10px">
      <label>Sun Azimuth</label>
      <span class="value" id="sunAzVal">160°</span>
    </div>
    <input type="range" id="sunAzimuth" min="0" max="360" step="1" value="160">
    <div class="control-row" style="margin-top:10px">
      <label>Turbidity</label>
      <span class="value" id="turbidityVal">0.4</span>
    </div>
    <input type="range" id="turbidity" min="0" max="1" step="0.01" value="0.4">
    <div class="btn-row">
      <button class="toggle-btn active" id="btnFoam">Foam</button>
      <button class="toggle-btn active" id="btnSSS">SSS</button>
      <button class="toggle-btn" id="btnWireframe">Wire</button>
    </div>
  </div>
</div>

<div id="stats">
  <div class="stat-grid">
    <div class="stat-item">
      <div class="stat-label">FPS</div>
      <div class="stat-value" id="fpsVal">60</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Beaufort</div>
      <div class="stat-value" id="beaufortVal">4</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Sig. Wave</div>
      <div class="stat-value" id="sigWaveVal">1.2m</div>
    </div>
    <div class="stat-item">
      <div class="stat-label">Coriolis</div>
      <div class="stat-value" id="coriolisVal">1.03e-4</div>
    </div>
  </div>
</div>

<svg id="compass" viewBox="0 0 80 80">
  <circle cx="40" cy="40" r="36" fill="none" stroke="rgba(122,184,255,0.15)" stroke-width="1"/>
  <text x="40" y="12" text-anchor="middle" fill="rgba(122,184,255,0.6)" font-family="JetBrains Mono" font-size="8">N</text>
  <text x="40" y="76" text-anchor="middle" fill="rgba(122,184,255,0.3)" font-family="JetBrains Mono" font-size="8">S</text>
  <text x="8" y="43" text-anchor="middle" fill="rgba(122,184,255,0.3)" font-family="JetBrains Mono" font-size="8">W</text>
  <text x="72" y="43" text-anchor="middle" fill="rgba(122,184,255,0.3)" font-family="JetBrains Mono" font-size="8">E</text>
  <line id="windArrow" x1="40" y1="40" x2="40" y2="16" stroke="#7ab8ff" stroke-width="2" stroke-linecap="round"/>
  <circle cx="40" cy="40" r="3" fill="#7ab8ff"/>
</svg>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
// OCEAN PHYSICS SIMULATOR
// Implements: Tessendorf wave model, Phillips spectrum,
// wind-wave interaction, gravity dispersion, Coriolis effect
// ============================================================

const CONFIG = {
  gridSize: 256,
  oceanSize: 200,
  wind: { speed: 12, direction: 45 },
  fetch: 800000,
  waveHeight: 1.0,
  choppiness: 1.2,
  wavePeriod: 8.0,
  gravity: 9.81,
  latitude: 45,
  omega: 7.29e-5,
  sunElevation: 35,
  sunAzimuth: 160,
  turbidity: 0.4,
  showFoam: true,
  showSSS: true,
  wireframe: false,
};

// ============================================================
// PHYSICS: Phillips Spectrum & Wave Generation (CPU)
// ============================================================
class OceanSpectrum {
  constructor(N, oceanSize) {
    this.N = N;
    this.oceanSize = oceanSize;
    this.h0 = new Float32Array(N * N * 2);
    this.h0conj = new Float32Array(N * N * 2);
    this.heights = new Float32Array(N * N);
    this.displaceX = new Float32Array(N * N);
    this.displaceZ = new Float32Array(N * N);
    this.normalX = new Float32Array(N * N);
    this.normalZ = new Float32Array(N * N);
    this.generateSpectrum();
  }

  // Gaussian random pair (Box-Muller)
  gaussianRandom() {
    let u1, u2;
    do { u1 = Math.random(); } while (u1 === 0);
    u2 = Math.random();
    const mag = Math.sqrt(-2.0 * Math.log(u1));
    return [mag * Math.cos(2 * Math.PI * u2), mag * Math.sin(2 * Math.PI * u2)];
  }

  // Phillips Spectrum with directional spreading and fetch limitation
  phillipsSpectrum(kx, kz) {
    const k2 = kx * kx + kz * kz;
    if (k2 < 1e-12) return 0;

    const k = Math.sqrt(k2);
    const g = CONFIG.gravity;
    const V = CONFIG.wind.speed;
    const L = (V * V) / g; // Largest possible wave from wind

    // Wind direction
    const wAngle = (CONFIG.wind.direction * Math.PI) / 180;
    const wdx = Math.cos(wAngle);
    const wdz = Math.sin(wAngle);

    // Directional factor
    const kNorm = 1 / k;
    const kDotW = (kx * kNorm) * wdx + (kz * kNorm) * wdz;
    const directional = Math.pow(Math.max(0, kDotW), 4);

    // Phillips spectrum
    const A = 4e-3 * CONFIG.waveHeight;
    const phillips = (A * Math.exp(-1.0 / (k2 * L * L))) / (k2 * k2) * directional;

    // Damping for very small waves
    const lSmall = L * 0.001;
    const damping = Math.exp(-k2 * lSmall * lSmall);

    // JONSWAP-like fetch limitation
    const fetchM = CONFIG.fetch;
    const kp = (g / (V * V)) * Math.pow(22 * g * fetchM / (V * V), -0.33);
    const gamma = 3.3;
    const sigma = k < kp ? 0.07 : 0.09;
    const r = Math.exp(-((k - kp) * (k - kp)) / (2 * sigma * sigma * kp * kp));
    const jonswap = Math.pow(gamma, r);

    return phillips * damping * jonswap;
  }

  generateSpectrum() {
    const N = this.N;
    const L = this.oceanSize;

    for (let m = 0; m < N; m++) {
      for (let n = 0; n < N; n++) {
        const kx = (2 * Math.PI * (n - N / 2)) / L;
        const kz = (2 * Math.PI * (m - N / 2)) / L;

        const ph = this.phillipsSpectrum(kx, kz);
        const phNeg = this.phillipsSpectrum(-kx, -kz);

        const [g1r, g1i] = this.gaussianRandom();
        const [g2r, g2i] = this.gaussianRandom();

        const sqrtPh = Math.sqrt(ph * 0.5);
        const sqrtPhNeg = Math.sqrt(phNeg * 0.5);

        const idx = (m * N + n) * 2;
        this.h0[idx] = sqrtPh * g1r;
        this.h0[idx + 1] = sqrtPh * g1i;
        this.h0conj[idx] = sqrtPhNeg * g2r;
        this.h0conj[idx + 1] = -sqrtPhNeg * g2i;
      }
    }
  }

  // Dispersion relation with Coriolis correction
  dispersion(kx, kz) {
    const k = Math.sqrt(kx * kx + kz * kz);
    const g = CONFIG.gravity;

    // Deep water dispersion: ω² = g·k
    let omega = Math.sqrt(g * k);

    // Coriolis parameter: f = 2Ω sin(φ)
    const f = 2 * CONFIG.omega * Math.sin((CONFIG.latitude * Math.PI) / 180);

    // Modified dispersion with inertial frequency floor
    // ω_eff = max(ω, |f|) — waves can't exist below inertial frequency
    if (omega < Math.abs(f)) {
      omega = Math.abs(f);
    }

    return omega;
  }

  // Evaluate ocean state at time t using DFT (simplified for real-time)
  evaluate(t) {
    const N = this.N;
    const L = this.oceanSize;
    const halfN = N / 2;

    // We use a simplified approach with layered Gerstner waves
    // derived from the spectrum for GPU-friendly computation
    // The actual height field is computed in the vertex shader
    // Here we precompute the spectral amplitudes modulated by time

    for (let m = 0; m < N; m++) {
      for (let n = 0; n < N; n++) {
        const kx = (2 * Math.PI * (n - halfN)) / L;
        const kz = (2 * Math.PI * (m - halfN)) / L;
        const k = Math.sqrt(kx * kx + kz * kz);

        const omega = this.dispersion(kx, kz);
        const phase = omega * t;

        const cosP = Math.cos(phase);
        const sinP = Math.sin(phase);

        const idx = (m * N + n) * 2;

        // h(k,t) = h0(k) * exp(iωt) + h0*(-k) * exp(-iωt)
        const h0r = this.h0[idx];
        const h0i = this.h0[idx + 1];
        const h0cr = this.h0conj[idx];
        const h0ci = this.h0conj[idx + 1];

        const hr = (h0r * cosP - h0i * sinP) + (h0cr * cosP + h0ci * sinP);
        const hi = (h0r * sinP + h0i * cosP) + (-h0cr * sinP + h0ci * cosP);

        const pIdx = m * N + n;
        this.heights[pIdx] = hr;

        // Horizontal displacement (Gerstner)
        if (k > 1e-6) {
          this.displaceX[pIdx] = -CONFIG.choppiness * (kx / k) * hi;
          this.displaceZ[pIdx] = -CONFIG.choppiness * (kz / k) * hi;
          this.normalX[pIdx] = -kx * hi;
          this.normalZ[pIdx] = -kz * hi;
        }
      }
    }
  }
}

// ============================================================
// RENDERING: Three.js Setup with Custom Shaders
// ============================================================

let scene, camera, renderer, oceanMesh, sky;
let spectrum;
let clock = new THREE.Clock();
let frameCount = 0;
let lastFpsTime = 0;

// Vertex shader: Gerstner wave displacement with multiple octaves
const oceanVertexShader = `
  precision highp float;

  uniform float uTime;
  uniform float uGravity;
  uniform float uWindSpeed;
  uniform float uWindDirX;
  uniform float uWindDirZ;
  uniform float uChoppiness;
  uniform float uWaveHeight;
  uniform float uWavePeriod;
  uniform float uCoriolisF;

  varying vec3 vWorldPos;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying float vFoam;
  varying float vHeight;
  varying vec3 vViewDir;

  // Simplex noise for small detail
  vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
  vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
  vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

  float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    vec3 i = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;
    i = mod289(i);
    vec4 p = permute(permute(permute(
      i.z + vec4(0.0, i1.z, i2.z, 1.0))
      + i.y + vec4(0.0, i1.y, i2.y, 1.0))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0));
    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ * ns.x + ns.yyyy;
    vec4 y = y_ * ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
  }

  // Gerstner wave function
  // Returns: vec3(displacement.x, height, displacement.z)
  vec3 gerstnerWave(vec2 pos, float amplitude, vec2 direction, float frequency, float speed, float steepness, float t) {
    float k = frequency;
    float omega = sqrt(uGravity * k); // Deep water dispersion
    float phase = k * dot(direction, pos) - omega * t;
    float c = cos(phase);
    float s = sin(phase);

    float dx = steepness * amplitude * direction.x * c;
    float dz = steepness * amplitude * direction.y * c;
    float dy = amplitude * s;

    return vec3(dx, dy, dz);
  }

  void main() {
    vUv = uv;
    vec3 pos = position;
    vec2 xz = pos.xz;

    float t = uTime;
    float totalHeight = 0.0;
    vec3 totalDisplacement = vec3(0.0);

    // Wind direction vector
    vec2 windDir = normalize(vec2(uWindDirX, uWindDirZ));

    // === MULTI-OCTAVE GERSTNER WAVES ===
    // Based on wind speed and gravity, we generate physically-based wave parameters

    // Dominant waves (swell)
    float L_dom = (uWindSpeed * uWindSpeed) / uGravity; // Dominant wavelength scale
    float k_dom = 6.28318 / max(L_dom * 2.0, 1.0);
    float amp_dom = uWaveHeight * uWindSpeed * 0.04;

    // Wave 1: Primary swell (aligned with wind)
    vec3 w1 = gerstnerWave(xz, amp_dom * 1.0, windDir, k_dom * 0.3, 1.0, uChoppiness * 0.7, t);

    // Wave 2: Secondary swell (slightly off-wind)
    vec2 dir2 = normalize(windDir + vec2(0.3, 0.2));
    vec3 w2 = gerstnerWave(xz, amp_dom * 0.7, dir2, k_dom * 0.5, 1.0, uChoppiness * 0.6, t * 1.1);

    // Wave 3: Cross-swell (Coriolis deflection - Ekman spiral)
    float ekmanAngle = uCoriolisF > 0.0 ? 0.35 : -0.35; // ~20° deflection
    vec2 ekmanDir = vec2(
      windDir.x * cos(ekmanAngle) - windDir.y * sin(ekmanAngle),
      windDir.x * sin(ekmanAngle) + windDir.y * cos(ekmanAngle)
    );
    vec3 w3 = gerstnerWave(xz, amp_dom * 0.5, ekmanDir, k_dom * 0.7, 1.0, uChoppiness * 0.5, t * 0.9);

    // Wave 4-6: Wind waves (shorter, steeper)
    vec3 w4 = gerstnerWave(xz, amp_dom * 0.35, windDir * 1.02, k_dom * 1.2, 1.0, uChoppiness * 0.9, t * 1.3);
    vec2 dir5 = normalize(windDir + vec2(-0.2, 0.15));
    vec3 w5 = gerstnerWave(xz, amp_dom * 0.25, dir5, k_dom * 1.8, 1.0, uChoppiness * 0.85, t * 1.5);
    vec2 dir6 = normalize(windDir + vec2(0.15, -0.25));
    vec3 w6 = gerstnerWave(xz, amp_dom * 0.2, dir6, k_dom * 2.5, 1.0, uChoppiness * 0.8, t * 1.7);

    // Wave 7-10: Capillary/ripple waves
    vec3 w7 = gerstnerWave(xz, amp_dom * 0.12, windDir, k_dom * 4.0, 1.0, uChoppiness * 0.6, t * 2.1);
    vec3 w8 = gerstnerWave(xz, amp_dom * 0.08, -ekmanDir, k_dom * 6.0, 1.0, uChoppiness * 0.4, t * 2.5);
    vec3 w9 = gerstnerWave(xz, amp_dom * 0.06, dir5 * 1.1, k_dom * 8.0, 1.0, uChoppiness * 0.3, t * 3.0);
    vec3 w10 = gerstnerWave(xz, amp_dom * 0.04, dir2 * 0.95, k_dom * 12.0, 1.0, uChoppiness * 0.2, t * 3.5);

    // Sum all waves
    totalDisplacement = w1 + w2 + w3 + w4 + w5 + w6 + w7 + w8 + w9 + w10;

    // Add noise-based micro detail
    float micro = snoise(vec3(xz * 0.15, t * 0.4)) * amp_dom * 0.08;
    micro += snoise(vec3(xz * 0.4, t * 0.7)) * amp_dom * 0.04;
    micro += snoise(vec3(xz * 1.2, t * 1.2)) * amp_dom * 0.015;

    pos.x += totalDisplacement.x;
    pos.y = totalDisplacement.y + micro;
    pos.z += totalDisplacement.z;

    vHeight = pos.y;

    // Compute normal via partial derivatives (finite differences approximation)
    float eps = 0.5;
    vec2 xzR = xz + vec2(eps, 0.0);
    vec2 xzU = xz + vec2(0.0, eps);

    vec3 wR1 = gerstnerWave(xzR, amp_dom * 1.0, windDir, k_dom * 0.3, 1.0, uChoppiness * 0.7, t);
    vec3 wR2 = gerstnerWave(xzR, amp_dom * 0.7, dir2, k_dom * 0.5, 1.0, uChoppiness * 0.6, t * 1.1);
    vec3 wR3 = gerstnerWave(xzR, amp_dom * 0.5, ekmanDir, k_dom * 0.7, 1.0, uChoppiness * 0.5, t * 0.9);
    vec3 wR4 = gerstnerWave(xzR, amp_dom * 0.35, windDir * 1.02, k_dom * 1.2, 1.0, uChoppiness * 0.9, t * 1.3);
    float hR = (wR1 + wR2 + wR3 + wR4).y + snoise(vec3(xzR * 0.15, t * 0.4)) * amp_dom * 0.08;

    vec3 wU1 = gerstnerWave(xzU, amp_dom * 1.0, windDir, k_dom * 0.3, 1.0, uChoppiness * 0.7, t);
    vec3 wU2 = gerstnerWave(xzU, amp_dom * 0.7, dir2, k_dom * 0.5, 1.0, uChoppiness * 0.6, t * 1.1);
    vec3 wU3 = gerstnerWave(xzU, amp_dom * 0.5, ekmanDir, k_dom * 0.7, 1.0, uChoppiness * 0.5, t * 0.9);
    vec3 wU4 = gerstnerWave(xzU, amp_dom * 0.35, windDir * 1.02, k_dom * 1.2, 1.0, uChoppiness * 0.9, t * 1.3);
    float hU = (wU1 + wU2 + wU3 + wU4).y + snoise(vec3(xzU * 0.15, t * 0.4)) * amp_dom * 0.08;

    float hC = totalDisplacement.y + micro;
    vec3 tangent = normalize(vec3(eps, hR - hC, 0.0));
    vec3 bitangent = normalize(vec3(0.0, hU - hC, eps));
    vNormal = normalize(cross(bitangent, tangent));

    // Foam: based on Jacobian (wave convergence/breaking)
    float jacobian = 1.0 - uChoppiness * (
      (totalDisplacement.x) * 0.05 + (totalDisplacement.z) * 0.05
    );
    vFoam = smoothstep(0.0, 1.0, 1.0 - jacobian) * 0.5;
    // Add crest foam
    vFoam += smoothstep(amp_dom * 0.4, amp_dom * 0.9, pos.y) * 0.7;
    vFoam = clamp(vFoam, 0.0, 1.0);

    vWorldPos = (modelMatrix * vec4(pos, 1.0)).xyz;
    vViewDir = normalize(cameraPosition - vWorldPos);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
  }
`;

// Fragment shader: PBR ocean rendering with SSS, foam, Fresnel
const oceanFragmentShader = `
  precision highp float;

  uniform vec3 uSunDir;
  uniform vec3 uSunColor;
  uniform float uTurbidity;
  uniform float uTime;
  uniform bool uShowFoam;
  uniform bool uShowSSS;

  varying vec3 vWorldPos;
  varying vec3 vNormal;
  varying vec2 vUv;
  varying float vFoam;
  varying float vHeight;
  varying vec3 vViewDir;

  // Fresnel-Schlick
  float fresnel(float cosTheta, float f0) {
    return f0 + (1.0 - f0) * pow(1.0 - cosTheta, 5.0);
  }

  // Simple noise for foam texture
  float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
  }

  float noise2D(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
  }

  float fbm(vec2 p) {
    float val = 0.0;
    float amp = 0.5;
    for (int i = 0; i < 5; i++) {
      val += amp * noise2D(p);
      p *= 2.1;
      amp *= 0.5;
    }
    return val;
  }

  void main() {
    vec3 N = normalize(vNormal);
    vec3 V = normalize(vViewDir);
    vec3 L = normalize(uSunDir);
    vec3 H = normalize(V + L);

    float NdotL = max(dot(N, L), 0.0);
    float NdotV = max(dot(N, V), 0.0);
    float NdotH = max(dot(N, H), 0.0);
    float VdotH = max(dot(V, H), 0.0);

    // === DEEP OCEAN COLOR ===
    vec3 deepColor = vec3(0.005, 0.03, 0.06);
    vec3 shallowColor = vec3(0.01, 0.08, 0.12);
    vec3 surfaceColor = vec3(0.02, 0.12, 0.18);

    // Mix based on view angle (looking down vs grazing)
    float depthFactor = pow(1.0 - NdotV, 3.0);
    vec3 waterColor = mix(deepColor, surfaceColor, depthFactor);

    // Turbidity
    vec3 turbidColor = vec3(0.04, 0.08, 0.06);
    waterColor = mix(waterColor, turbidColor, uTurbidity * 0.5);

    // === FRESNEL REFLECTION ===
    float F = fresnel(NdotV, 0.02);

    // Sky color approximation
    vec3 skyColor = vec3(0.4, 0.55, 0.75);
    vec3 horizonColor = vec3(0.65, 0.72, 0.82);

    // Reflected sky color based on normal
    float skyGradient = max(dot(reflect(-V, N), vec3(0, 1, 0)), 0.0);
    vec3 reflectedSky = mix(horizonColor, skyColor, skyGradient);

    // === SPECULAR (GGX) ===
    float roughness = 0.15;
    float alpha = roughness * roughness;
    float alpha2 = alpha * alpha;
    float denom = NdotH * NdotH * (alpha2 - 1.0) + 1.0;
    float D = alpha2 / (3.14159 * denom * denom);
    float G = min(1.0, min(2.0 * NdotH * NdotV / VdotH, 2.0 * NdotH * NdotL / VdotH));
    float specular = D * G * F / max(4.0 * NdotV * NdotL, 0.001);

    // Sun reflection (sharp highlight)
    float sunSpec = pow(NdotH, 800.0) * 50.0;
    vec3 sunReflection = uSunColor * sunSpec;

    // Broader sun glitter
    float glitter = pow(NdotH, 120.0) * 4.0;
    sunReflection += uSunColor * glitter * 0.5;

    // === SUBSURFACE SCATTERING ===
    vec3 sss = vec3(0.0);
    if (uShowSSS) {
      // Light passing through wave crests
      float sssIntensity = pow(max(dot(V, -L + N * 0.6), 0.0), 4.0);
      vec3 sssColor = vec3(0.05, 0.3, 0.25);
      sss = sssColor * sssIntensity * max(vHeight * 0.3, 0.0);

      // Back-lit wave tips
      float backlight = pow(max(dot(-V, L), 0.0), 3.0);
      sss += vec3(0.02, 0.18, 0.15) * backlight * max(vHeight * 0.2, 0.0);
    }

    // === FOAM ===
    vec3 foamContrib = vec3(0.0);
    if (uShowFoam) {
      float foamNoise = fbm(vWorldPos.xz * 1.5 + uTime * 0.3);
      float foamNoise2 = fbm(vWorldPos.xz * 3.0 - uTime * 0.15);
      float foamMask = vFoam * foamNoise * foamNoise2;
      foamMask = smoothstep(0.05, 0.3, foamMask);

      vec3 foamColor = vec3(0.85, 0.9, 0.95);
      foamContrib = foamColor * foamMask * (0.7 + 0.3 * NdotL);
    }

    // === COMPOSITE ===
    vec3 ambient = waterColor * vec3(0.15, 0.2, 0.3);
    vec3 diffuse = waterColor * NdotL * uSunColor * 0.3;
    vec3 reflection = reflectedSky * F;
    vec3 refraction = waterColor * (1.0 - F);

    vec3 color = ambient + diffuse + reflection + refraction + sss;
    color += sunReflection;
    color += uSunColor * specular * 0.5;
    color += foamContrib;

    // === ATMOSPHERIC FOG ===
    float dist = length(vWorldPos - cameraPosition);
    float fogFactor = 1.0 - exp(-dist * 0.003);
    vec3 fogColor = mix(vec3(0.55, 0.62, 0.72), vec3(0.75, 0.8, 0.88), fogFactor);
    color = mix(color, fogColor, fogFactor * 0.7);

    // Tone mapping (ACES)
    color = color * (2.51 * color + 0.03) / (color * (2.43 * color + 0.59) + 0.14);

    // Gamma
    color = pow(color, vec3(1.0 / 2.2));

    gl_FragColor = vec4(color, 1.0);
  }
`;

// Sky vertex shader
const skyVertexShader = `
  varying vec3 vDirection;
  void main() {
    vDirection = position;
    vec4 pos = projectionMatrix * mat4(mat3(viewMatrix)) * vec4(position, 1.0);
    gl_Position = pos.xyww;
  }
`;

// Sky fragment shader — physically-based atmospheric scattering
const skyFragmentShader = `
  precision highp float;
  uniform vec3 uSunDir;
  varying vec3 vDirection;

  void main() {
    vec3 dir = normalize(vDirection);
    float sunDot = max(dot(dir, normalize(uSunDir)), 0.0);

    // Rayleigh scattering approximation
    vec3 skyTop = vec3(0.25, 0.45, 0.85);
    vec3 skyHorizon = vec3(0.6, 0.7, 0.85);
    vec3 skyBottom = vec3(0.4, 0.5, 0.65);

    float y = dir.y;
    vec3 skyColor;
    if (y > 0.0) {
      skyColor = mix(skyHorizon, skyTop, pow(y, 0.6));
    } else {
      skyColor = mix(skyHorizon, skyBottom, pow(-y, 0.3));
    }

    // Sun disk
    float sunDisk = smoothstep(0.9994, 0.9999, sunDot);
    vec3 sunColor = vec3(1.0, 0.95, 0.85) * 3.0;

    // Sun glow
    float sunGlow = pow(sunDot, 8.0) * 0.5;
    vec3 glowColor = vec3(1.0, 0.85, 0.6);

    // Mie scattering (forward scatter halo)
    float mie = pow(sunDot, 32.0) * 0.3;
    vec3 mieColor = vec3(1.0, 0.9, 0.7);

    vec3 color = skyColor + sunColor * sunDisk + glowColor * sunGlow + mieColor * mie;

    // Clouds (simple procedural)
    float cloudY = smoothstep(0.05, 0.5, y);
    float cloud = 0.0;
    if (y > 0.0) {
      vec2 cp = dir.xz / (y + 0.1) * 3.0;
      cloud = smoothstep(0.45, 0.55, 
        sin(cp.x * 0.8) * 0.3 + sin(cp.y * 0.6 + 1.0) * 0.3 + 
        sin(cp.x * 1.3 + cp.y * 0.7) * 0.2 + 0.5
      ) * cloudY * 0.4;
    }
    color = mix(color, vec3(1.0), cloud);

    // Tone mapping
    color = color / (color + 1.0);
    color = pow(color, vec3(1.0 / 2.2));

    gl_FragColor = vec4(color, 1.0);
  }
`;

function init() {
  // Scene
  scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 10000);
  camera.position.set(0, 8, 30);
  camera.lookAt(0, 0, 0);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.insertBefore(renderer.domElement, document.body.firstChild);

  // Sky sphere
  const skyGeo = new THREE.SphereGeometry(5000, 32, 32);
  const skyMat = new THREE.ShaderMaterial({
    vertexShader: skyVertexShader,
    fragmentShader: skyFragmentShader,
    uniforms: {
      uSunDir: { value: new THREE.Vector3() }
    },
    side: THREE.BackSide,
    depthWrite: false,
  });
  sky = new THREE.Mesh(skyGeo, skyMat);
  scene.add(sky);

  // Ocean mesh
  const oceanGeo = new THREE.PlaneGeometry(
    CONFIG.oceanSize, CONFIG.oceanSize,
    CONFIG.gridSize, CONFIG.gridSize
  );
  oceanGeo.rotateX(-Math.PI / 2);

  const sunDir = getSunDirection();

  const oceanMat = new THREE.ShaderMaterial({
    vertexShader: oceanVertexShader,
    fragmentShader: oceanFragmentShader,
    uniforms: {
      uTime: { value: 0 },
      uGravity: { value: CONFIG.gravity },
      uWindSpeed: { value: CONFIG.wind.speed },
      uWindDirX: { value: Math.cos(CONFIG.wind.direction * Math.PI / 180) },
      uWindDirZ: { value: Math.sin(CONFIG.wind.direction * Math.PI / 180) },
      uChoppiness: { value: CONFIG.choppiness },
      uWaveHeight: { value: CONFIG.waveHeight },
      uWavePeriod: { value: CONFIG.wavePeriod },
      uCoriolisF: { value: 2 * CONFIG.omega * Math.sin(CONFIG.latitude * Math.PI / 180) },
      uSunDir: { value: sunDir },
      uSunColor: { value: new THREE.Vector3(1.0, 0.95, 0.85) },
      uTurbidity: { value: CONFIG.turbidity },
      uShowFoam: { value: CONFIG.showFoam },
      uShowSSS: { value: CONFIG.showSSS },
    },
    wireframe: CONFIG.wireframe,
  });

  oceanMesh = new THREE.Mesh(oceanGeo, oceanMat);
  scene.add(oceanMesh);

  // Initialize spectrum
  spectrum = new OceanSpectrum(64, CONFIG.oceanSize);

  // Camera controls (simple orbit)
  setupControls();
  setupUI();

  // Remove loading
  setTimeout(() => {
    document.getElementById('loading').classList.add('fade-out');
    setTimeout(() => document.getElementById('loading').remove(), 800);
  }, 800);

  animate();
}

function getSunDirection() {
  const elev = CONFIG.sunElevation * Math.PI / 180;
  const az = CONFIG.sunAzimuth * Math.PI / 180;
  return new THREE.Vector3(
    Math.cos(elev) * Math.sin(az),
    Math.sin(elev),
    Math.cos(elev) * Math.cos(az)
  ).normalize();
}

// ============================================================
// CAMERA CONTROLS
// ============================================================
let camTheta = 0.3, camPhi = 0.2, camDist = 40;
let isDragging = false, lastMX = 0, lastMY = 0;
let targetTheta = camTheta, targetPhi = camPhi, targetDist = camDist;

function setupControls() {
  const canvas = renderer.domElement;

  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastMX = e.clientX;
    lastMY = e.clientY;
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - lastMX;
    const dy = e.clientY - lastMY;
    targetTheta -= dx * 0.005;
    targetPhi = Math.max(-0.02, Math.min(Math.PI / 2.2, targetPhi + dy * 0.005));
    lastMX = e.clientX;
    lastMY = e.clientY;
  });

  canvas.addEventListener('mouseup', () => isDragging = false);
  canvas.addEventListener('mouseleave', () => isDragging = false);

  canvas.addEventListener('wheel', (e) => {
    targetDist = Math.max(5, Math.min(200, targetDist + e.deltaY * 0.05));
  });

  // Touch
  canvas.addEventListener('touchstart', (e) => {
    if (e.touches.length === 1) {
      isDragging = true;
      lastMX = e.touches[0].clientX;
      lastMY = e.touches[0].clientY;
    }
  });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 1 && isDragging) {
      const dx = e.touches[0].clientX - lastMX;
      const dy = e.touches[0].clientY - lastMY;
      targetTheta -= dx * 0.005;
      targetPhi = Math.max(-0.02, Math.min(Math.PI / 2.2, targetPhi + dy * 0.005));
      lastMX = e.touches[0].clientX;
      lastMY = e.touches[0].clientY;
    }
  }, { passive: false });

  canvas.addEventListener('touchend', () => isDragging = false);

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
}

// ============================================================
// UI BINDINGS
// ============================================================
function setupUI() {
  const bind = (id, configKey, display, parent) => {
    const el = document.getElementById(id);
    const valEl = document.getElementById(id + 'Val');
    el.addEventListener('input', () => {
      const v = parseFloat(el.value);
      if (parent) CONFIG[parent][configKey] = v;
      else CONFIG[configKey] = v;
      if (valEl) valEl.textContent = display(v);
      updateUniforms();
    });
  };

  bind('windSpeed', 'speed', v => v.toFixed(1) + ' m/s', 'wind');
  bind('windDir', 'direction', v => v + '°', 'wind');
  bind('fetchDist', null, v => v, null);
  document.getElementById('fetchDist').addEventListener('input', (e) => {
    CONFIG.fetch = parseFloat(e.target.value) * 1000;
    document.getElementById('fetchVal').textContent = e.target.value;
  });

  bind('waveHeight', 'waveHeight', v => v.toFixed(1) + 'x');
  bind('choppiness', 'choppiness', v => v.toFixed(1));
  bind('wavePeriod', 'wavePeriod', v => v.toFixed(1) + ' s');
  bind('gravity', 'gravity', v => v.toFixed(2) + ' m/s²');
  bind('latitude', 'latitude', v => v + '° ' + (v >= 0 ? 'N' : 'S'));
  bind('sunElevation', 'sunElevation', v => v + '°');
  bind('sunAzimuth', 'sunAzimuth', v => v + '°');
  bind('turbidity', 'turbidity', v => v.toFixed(2));

  document.getElementById('omega').addEventListener('input', (e) => {
    CONFIG.omega = parseFloat(e.target.value) * 1e-5;
    document.getElementById('omegaVal').textContent = parseFloat(e.target.value).toFixed(2) + 'e-5';
    updateUniforms();
  });

  // Toggles
  document.getElementById('btnFoam').addEventListener('click', (e) => {
    CONFIG.showFoam = !CONFIG.showFoam;
    e.target.classList.toggle('active');
    updateUniforms();
  });

  document.getElementById('btnSSS').addEventListener('click', (e) => {
    CONFIG.showSSS = !CONFIG.showSSS;
    e.target.classList.toggle('active');
    updateUniforms();
  });

  document.getElementById('btnWireframe').addEventListener('click', (e) => {
    CONFIG.wireframe = !CONFIG.wireframe;
    e.target.classList.toggle('active');
    oceanMesh.material.wireframe = CONFIG.wireframe;
  });
}

function updateUniforms() {
  const u = oceanMesh.material.uniforms;
  u.uGravity.value = CONFIG.gravity;
  u.uWindSpeed.value = CONFIG.wind.speed;
  u.uWindDirX.value = Math.cos(CONFIG.wind.direction * Math.PI / 180);
  u.uWindDirZ.value = Math.sin(CONFIG.wind.direction * Math.PI / 180);
  u.uChoppiness.value = CONFIG.choppiness;
  u.uWaveHeight.value = CONFIG.waveHeight;
  u.uWavePeriod.value = CONFIG.wavePeriod;
  u.uCoriolisF.value = 2 * CONFIG.omega * Math.sin(CONFIG.latitude * Math.PI / 180);
  u.uTurbidity.value = CONFIG.turbidity;
  u.uShowFoam.value = CONFIG.showFoam;
  u.uShowSSS.value = CONFIG.showSSS;

  const sunDir = getSunDirection();
  u.uSunDir.value.copy(sunDir);
  sky.material.uniforms.uSunDir.value.copy(sunDir);

  // Update compass wind arrow
  const angle = CONFIG.wind.direction;
  const rad = (angle) * Math.PI / 180;
  const ax = 40 + 22 * Math.sin(rad);
  const ay = 40 - 22 * Math.cos(rad);
  document.getElementById('windArrow').setAttribute('x2', ax);
  document.getElementById('windArrow').setAttribute('y2', ay);

  // Regenerate spectrum if wind changed significantly
  if (spectrum) {
    spectrum.generateSpectrum();
  }

  updateStats();
}

function updateStats() {
  // Beaufort scale from wind speed
  const ws = CONFIG.wind.speed;
  let beaufort = 0;
  const bLimits = [0.3, 1.6, 3.4, 5.5, 8.0, 10.8, 13.9, 17.2, 20.8, 24.5, 28.5, 32.7];
  for (let i = 0; i < bLimits.length; i++) {
    if (ws >= bLimits[i]) beaufort = i + 1;
  }
  document.getElementById('beaufortVal').textContent = beaufort;

  // Significant wave height (Hs ≈ 0.0246 * V² / g for fully developed sea)
  const Hs = 0.0246 * ws * ws / CONFIG.gravity * CONFIG.waveHeight;
  document.getElementById('sigWaveVal').textContent = Hs.toFixed(1) + 'm';

  // Coriolis parameter
  const f = 2 * CONFIG.omega * Math.sin(CONFIG.latitude * Math.PI / 180);
  document.getElementById('coriolisVal').textContent = f.toExponential(2);
}

// ============================================================
// ANIMATION LOOP
// ============================================================
function animate() {
  requestAnimationFrame(animate);

  const dt = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  // Smooth camera
  camTheta += (targetTheta - camTheta) * 0.08;
  camPhi += (targetPhi - camPhi) * 0.08;
  camDist += (targetDist - camDist) * 0.08;

  camera.position.x = camDist * Math.cos(camPhi) * Math.sin(camTheta);
  camera.position.y = camDist * Math.sin(camPhi) + 3;
  camera.position.z = camDist * Math.cos(camPhi) * Math.cos(camTheta);
  camera.lookAt(0, 0, 0);

  // Update shader time
  oceanMesh.material.uniforms.uTime.value = elapsed;

  // FPS counter
  frameCount++;
  if (elapsed - lastFpsTime >= 0.5) {
    const fps = Math.round(frameCount / (elapsed - lastFpsTime));
    document.getElementById('fpsVal').textContent = fps;
    frameCount = 0;
    lastFpsTime = elapsed;
  }

  renderer.render(scene, camera);
}

// Start
init();
</script>
</body>
</html>
